#Декларативноепрограммирование 

 * reduce(function, iterable, initializer)

* reduce() принимает функцию, итерацию (или несколько итераций) и инициализатор в качестве аргументов. Кумулятивно применяет функцию *function* к элементам итерируемой *iterable* последовательности, сводя её к единственному значению.

* Первый аргумент reduce() -  это функция, которая преобразует каждый исходный элемент в новый (преобразованный) элемент. Сюда входят встроенные функции, классы, методы, лямбда-функции и пользовательские функции.

* Второй аргумент reduce() - итерируемый объект. Это может быть список, множество, кортеж, словарь, строка и др.

* Третий аргумент reduce() - помещается перед элементами *iterable* в вычислении и используется по умолчанию, когда *iterable* пуст. Это означает, что первый вызов функции будет использовать значение инициализатора и первый элемент *iterable* для выполнения своего первого частичного вычисления. После этого reduce() продолжает работать с последующими элементами *iterable*. Если инициализатор не задан и *iterable* содержит только один элемент, возвращается первый элемент. Если итерируемый объект пуст и инициализатора нет, то будет ошибка. Следует указать инициализатор, если потенциальный  итерируемый объект может быть пустым, тогда в ответе будет инициализатор. 

```jupyter 
import random  
from functools import reduce  
  
initial_list = [random.randint(-20, 20) for _ in range(random.randint(0, 10))]  
print(f'Initial list: {initial_list}')  
  
sum_list_num = reduce(lambda x, y: x + y, initial_list)  
print(f'Sum of the numbers in the list: {sum_list_num}')
```

Пример с использованием инициализатора.

```jupyter
import random  
from functools import reduce  
  
initial_list = [random.randint(-20, 20) for _ in range(random.randint(0, 10))]  
print(f'Initial list: {initial_list}')  
  
sum_list_num = reduce(lambda x, y: x + y, initial_list, 100)  
print(f'Sum of the numbers in the list: {sum_list_num}')

```
Значение 100 используется в качестве 1 аргумента. К нему прибавляется элемент 1 массива, затем 2 и так далее. При использовании инициализатора функция reduce() выполнит на 1 итерацию больше чем без него.